#include "ConfigStorage.h"
#include "../persistence/FormKeyUtil.h"
#include "../log.h"
#include <Windows.h>
#include <filesystem>
#include <fstream>
#include <fmt/format.h>

namespace Config {

ConfigStorage* ConfigStorage::GetSingleton()
{
    static ConfigStorage instance;
    return &instance;
}

void ConfigStorage::Initialize(std::string_view modName)
{
    std::lock_guard<std::mutex> lock(m_mutex);

    if (m_initialized) {
        spdlog::warn("ConfigStorage: Already initialized as '{}', ignoring re-init as '{}'",
            m_modName, modName);
        return;
    }

    m_modName = modName;

    // Build path: Data\SKSE\Plugins\<ModName>\<ModName>_config.ini
    char pathBuffer[MAX_PATH];
    GetModuleFileNameA(nullptr, pathBuffer, MAX_PATH);
    std::string exePath(pathBuffer);
    std::string dataPath = exePath.substr(0, exePath.rfind('\\'));

    m_iniFolderPath = fmt::format("{}\\Data\\SKSE\\Plugins\\{}", dataPath, m_modName);
    m_iniPath = fmt::format("{}\\{}_config.ini", m_iniFolderPath, m_modName);

    spdlog::info("ConfigStorage: Initialized for '{}' at '{}'", m_modName, m_iniPath);
    m_initialized = true;
}

void ConfigStorage::EnsureIniFileExists()
{
    namespace fs = std::filesystem;

    // Create folder if needed
    if (!fs::exists(m_iniFolderPath)) {
        fs::create_directories(m_iniFolderPath);
        spdlog::info("ConfigStorage: Created directory '{}'", m_iniFolderPath);
    }

    // Create INI file with header if needed
    if (!fs::exists(m_iniPath)) {
        std::ofstream file(m_iniPath);
        if (file) {
            file << "; " << m_modName << " Configuration\n";
            file << "; Auto-generated by ConfigStorage\n\n";
            file << "[General]\n";
            file.close();
            spdlog::info("ConfigStorage: Created INI file '{}'", m_iniPath);
        } else {
            spdlog::error("ConfigStorage: Failed to create INI file '{}'", m_iniPath);
        }
    }
}

std::pair<std::string, std::string> ConfigStorage::ParseSectionKey(std::string_view qualifiedKey)
{
    size_t colonPos = qualifiedKey.find(':');
    if (colonPos != std::string_view::npos) {
        return {
            std::string(qualifiedKey.substr(0, colonPos)),
            std::string(qualifiedKey.substr(colonPos + 1))
        };
    }
    return { "General", std::string(qualifiedKey) };
}

std::string ConfigStorage::ReadIniString(const std::string& section, const std::string& key,
                                          const std::string& defaultValue)
{
    char buffer[4096];
    DWORD result = GetPrivateProfileStringA(
        section.c_str(), key.c_str(), defaultValue.c_str(),
        buffer, sizeof(buffer), m_iniPath.c_str());
    return std::string(buffer, result);
}

void ConfigStorage::WriteIniString(const std::string& section, const std::string& key,
                                    const std::string& value)
{
    EnsureIniFileExists();
    WritePrivateProfileStringA(section.c_str(), key.c_str(), value.c_str(), m_iniPath.c_str());
}

bool ConfigStorage::KeyExists(const std::string& section, const std::string& key)
{
    // Use a sentinel value that's extremely unlikely to be a real value
    // If we get back the sentinel, the key doesn't exist
    constexpr const char* sentinel = "\x01\x02__KEY_NOT_FOUND__\x02\x01";
    char buffer[256];
    DWORD result = GetPrivateProfileStringA(
        section.c_str(), key.c_str(), sentinel,
        buffer, sizeof(buffer), m_iniPath.c_str());

    return strcmp(buffer, sentinel) != 0;
}

// ========== Registration (C++ only) ==========

int ConfigStorage::RegisterIntOption(std::string_view key, int defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);

    // Store the default for Reset* to use later
    m_intDefaults[std::string(key)] = defaultValue;

    if (!KeyExists(section, keyName)) {
        WriteIniString(section, keyName, std::to_string(defaultValue));
        spdlog::info("ConfigStorage: Registered [{}]{} = {} (default)", section, keyName, defaultValue);
        return defaultValue;
    }

    // Key exists, return current value
    return GetPrivateProfileIntA(section.c_str(), keyName.c_str(), defaultValue, m_iniPath.c_str());
}

float ConfigStorage::RegisterFloatOption(std::string_view key, float defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);

    // Store the default for Reset* to use later
    m_floatDefaults[std::string(key)] = defaultValue;

    if (!KeyExists(section, keyName)) {
        WriteIniString(section, keyName, fmt::format("{:.6f}", defaultValue));
        spdlog::info("ConfigStorage: Registered [{}]{} = {:.6f} (default)", section, keyName, defaultValue);
        return defaultValue;
    }

    // Key exists, return current value
    std::string defStr = fmt::format("{:.6f}", defaultValue);
    std::string value = ReadIniString(section, keyName, defStr);
    try {
        return std::stof(value);
    } catch (...) {
        return defaultValue;
    }
}

std::string ConfigStorage::RegisterStringOption(std::string_view key, std::string_view defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);

    // Store the default for Reset* to use later
    m_stringDefaults[std::string(key)] = std::string(defaultValue);

    if (!KeyExists(section, keyName)) {
        WriteIniString(section, keyName, std::string(defaultValue));
        spdlog::info("ConfigStorage: Registered [{}]{} = '{}' (default)", section, keyName, defaultValue);
        return std::string(defaultValue);
    }

    // Key exists, return current value
    return ReadIniString(section, keyName, std::string(defaultValue));
}

// ========== Int ==========

int ConfigStorage::GetInt(std::string_view key, int defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);
    return GetPrivateProfileIntA(section.c_str(), keyName.c_str(), defaultValue, m_iniPath.c_str());
}

int ConfigStorage::SetInt(std::string_view key, int value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);
    WriteIniString(section, keyName, std::to_string(value));
    spdlog::trace("ConfigStorage: Set [{}]{} = {}", section, keyName, value);
    return value;
}

int ConfigStorage::ResetInt(std::string_view key, int defaultValue)
{
    // Use registered default if available, otherwise fall back to provided default
    int actualDefault = defaultValue;
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        auto it = m_intDefaults.find(std::string(key));
        if (it != m_intDefaults.end()) {
            actualDefault = it->second;
        }
    }
    return SetInt(key, actualDefault);
}

// ========== Float ==========

float ConfigStorage::GetFloat(std::string_view key, float defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);
    std::string defStr = fmt::format("{:.6f}", defaultValue);
    std::string value = ReadIniString(section, keyName, defStr);
    try {
        return std::stof(value);
    } catch (...) {
        return defaultValue;
    }
}

float ConfigStorage::SetFloat(std::string_view key, float value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);
    WriteIniString(section, keyName, fmt::format("{:.6f}", value));
    spdlog::trace("ConfigStorage: Set [{}]{} = {:.6f}", section, keyName, value);
    return value;
}

float ConfigStorage::ResetFloat(std::string_view key, float defaultValue)
{
    // Use registered default if available, otherwise fall back to provided default
    float actualDefault = defaultValue;
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        auto it = m_floatDefaults.find(std::string(key));
        if (it != m_floatDefaults.end()) {
            actualDefault = it->second;
        }
    }
    return SetFloat(key, actualDefault);
}

// ========== String ==========

std::string ConfigStorage::GetString(std::string_view key, std::string_view defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);
    return ReadIniString(section, keyName, std::string(defaultValue));
}

std::string ConfigStorage::SetString(std::string_view key, std::string_view value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);
    WriteIniString(section, keyName, std::string(value));
    spdlog::trace("ConfigStorage: Set [{}]{} = '{}'", section, keyName, value);
    return std::string(value);
}

std::string ConfigStorage::ResetString(std::string_view key, std::string_view defaultValue)
{
    // Use registered default if available, otherwise fall back to provided default
    std::string actualDefault(defaultValue);
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        auto it = m_stringDefaults.find(std::string(key));
        if (it != m_stringDefaults.end()) {
            actualDefault = it->second;
        }
    }
    return SetString(key, actualDefault);
}

// ========== Form ==========

RE::TESForm* ConfigStorage::GetForm(std::string_view key, RE::TESForm* defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);

    // Build default FormKey string
    std::string defaultFormKey = defaultValue
        ? Persistence::FormKeyUtil::BuildFormKey(defaultValue)
        : "";

    std::string formKey = ReadIniString(section, keyName, defaultFormKey);
    if (formKey.empty()) {
        return defaultValue;
    }

    // Resolve FormKey to runtime Form
    RE::FormID runtimeId = Persistence::FormKeyUtil::ResolveToRuntimeFormID(formKey);
    if (runtimeId == 0) {
        spdlog::warn("ConfigStorage: Failed to resolve FormKey '{}' for [{}]{}",
            formKey, section, keyName);
        return defaultValue;
    }

    auto* form = RE::TESForm::LookupByID(runtimeId);
    return form ? form : defaultValue;
}

RE::TESForm* ConfigStorage::SetForm(std::string_view key, RE::TESForm* value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    auto [section, keyName] = ParseSectionKey(key);

    std::string formKey = value ? Persistence::FormKeyUtil::BuildFormKey(value) : "";
    WriteIniString(section, keyName, formKey);
    spdlog::trace("ConfigStorage: Set [{}]{} = '{}' (Form)", section, keyName, formKey);
    return value;
}

RE::TESForm* ConfigStorage::ResetForm(std::string_view key, RE::TESForm* defaultValue)
{
    return SetForm(key, defaultValue);
}

// ========== Select ==========

void ConfigStorage::RegisterSelectOptions(std::string_view key, const std::vector<std::string>& options,
                                           std::string_view defaultValue)
{
    std::lock_guard<std::mutex> lock(m_mutex);

    if (options.empty()) {
        spdlog::warn("ConfigStorage: Cannot register empty options list for '{}'", key);
        return;
    }

    m_selectOptions[std::string(key)] = options;

    // Determine the actual default: use provided defaultValue if valid, else first option
    std::string actualDefault;
    if (defaultValue.empty()) {
        actualDefault = options[0];
    } else {
        // Validate defaultValue is in options list
        bool found = false;
        for (const auto& opt : options) {
            if (opt == defaultValue) {
                found = true;
                break;
            }
        }
        if (found) {
            actualDefault = defaultValue;
        } else {
            spdlog::warn("ConfigStorage: Default '{}' not in options for '{}', using first option",
                defaultValue, key);
            actualDefault = options[0];
        }
    }

    // Store the default for ResetSelect to use later
    m_selectDefaults[std::string(key)] = actualDefault;

    // Write default to INI if key doesn't exist
    auto [section, keyName] = ParseSectionKey(key);
    if (!KeyExists(section, keyName)) {
        WriteIniString(section, keyName, actualDefault);
        spdlog::info("ConfigStorage: Registered select [{}]{} = '{}' (default, {} options)",
            section, keyName, actualDefault, options.size());
    } else {
        spdlog::info("ConfigStorage: Registered select [{}]{} ({} options, existing value kept)",
            section, keyName, options.size());
    }
}

std::string ConfigStorage::GetSelect(std::string_view key)
{
    std::lock_guard<std::mutex> lock(m_mutex);

    auto it = m_selectOptions.find(std::string(key));
    if (it == m_selectOptions.end() || it->second.empty()) {
        return "Option Not Found";
    }

    auto [section, keyName] = ParseSectionKey(key);
    std::string defaultOption = it->second[0];  // First option is default
    return ReadIniString(section, keyName, defaultOption);
}

std::string ConfigStorage::SetSelect(std::string_view key, std::string_view value)
{
    std::lock_guard<std::mutex> lock(m_mutex);

    // Validate against registered options
    auto it = m_selectOptions.find(std::string(key));
    if (it != m_selectOptions.end()) {
        bool valid = false;
        for (const auto& opt : it->second) {
            if (opt == value) {
                valid = true;
                break;
            }
        }
        if (!valid) {
            spdlog::warn("ConfigStorage: Invalid select value '{}' for key '{}', ignoring", value, key);
            // Return current value (need to read without lock, so unlock first)
            auto [section, keyName] = ParseSectionKey(key);
            std::string defaultOption = it->second.empty() ? "Option Not Found" : it->second[0];
            return ReadIniString(section, keyName, defaultOption);
        }
    }

    auto [section, keyName] = ParseSectionKey(key);
    WriteIniString(section, keyName, std::string(value));
    spdlog::trace("ConfigStorage: Set [{}]{} = '{}' (Select)", section, keyName, value);
    return std::string(value);
}

std::vector<std::string> ConfigStorage::GetSelectOptions(std::string_view key)
{
    std::lock_guard<std::mutex> lock(m_mutex);

    auto it = m_selectOptions.find(std::string(key));
    if (it != m_selectOptions.end()) {
        return it->second;
    }
    return { "Option Not Found" };
}

std::string ConfigStorage::ResetSelect(std::string_view key)
{
    std::lock_guard<std::mutex> lock(m_mutex);

    auto it = m_selectOptions.find(std::string(key));
    if (it == m_selectOptions.end() || it->second.empty()) {
        return "Option Not Found";
    }

    // Use stored default from RegisterSelectOptions, or fall back to first option
    std::string defaultOption;
    auto defIt = m_selectDefaults.find(std::string(key));
    if (defIt != m_selectDefaults.end()) {
        defaultOption = defIt->second;
    } else {
        defaultOption = it->second[0];  // Fallback to first option
    }

    auto [section, keyName] = ParseSectionKey(key);
    WriteIniString(section, keyName, defaultOption);
    return defaultOption;
}

// ========== Utility ==========

void ConfigStorage::FlushToDisk()
{
    // Windows INI API writes immediately, but this can force any buffered writes
    WritePrivateProfileStringA(nullptr, nullptr, nullptr, m_iniPath.c_str());
}

void ConfigStorage::ReloadFromDisk()
{
    // Windows INI API reads fresh from disk each time - no caching to clear
    spdlog::info("ConfigStorage: ReloadFromDisk (INI API reads fresh each time)");
}

} // namespace Config
